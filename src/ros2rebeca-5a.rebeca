
//ROS2 to Rebeca modelling

//The source code contained herein is developed and owned by Hong Hiep Trinh (trinhhong.hiep@gmail.com)
//for the master thesis project at Malardalens University (2021-2023).
//Release date: 2023-05-17
//(C) All rights reserved.

env int MAP_ROWS=50;	//rows
env int MAP_COLS=50;	//cols
env double MAP_RESOL=0.05;	//scale, 1 cell size is equal to 0.05 meters

env int ROBOT_BREADTH = 4;	//measure in cells = real measure/map_resolution
env int ROBOT_LENGTH = 4;
env int ROBOT_RADIUS = 2;
env int SAFE_MARGIN = 1;	
env int STOP_ZONE = 5;		

env int ANGLE_INC = 2; //angle increment in degrees, fixed value, do not change
env int FIELD_OF_VIEW = 120;		//field of view (LIDAR sensor)
env int LASERSCAN_RATE = 140;	//7Hz
env int LASERSCAN_MAX_DISTANCE = 20;	//= max range in meters / MAP_RESOL
env int MAX_WAITING_TIME = 1400;	//5s

env int BUFFER_SIZE = 101;	//generic bufffer size + 1 (counter)

//directions, start from East = 0, moving counter-clockwise 45o each direction
env int DIR_E 	= 0;
env int DIR_NE 	= 1;
env int DIR_N 	= 2;
env int DIR_NW 	= 3;
env int DIR_W 	= 4;
env int DIR_SW 	= 5;
env int DIR_S 	= 6;
env int DIR_SE 	= 7;

//approximation threshold
env double EPSILON = 0.01;
env double INFINITY = 9999;
env double PI = 3.14;
env double SQRT2 = 1.4142;
env double SIN45 = 0.7071;	//sqrt2/2
env double COS45 = 0.7071;
//Rebeca does not support defining constant array of doubles
//env double[8] SINS = {0,SIN45,1,SIN45,0,-SIN45,-1,-SIN45};
//env double[8] COSS = {1,SIN45,0,-SIN45,-1,-SIN45,0,SIN45};

//movement commands: byte #1 = move type, byte #2 = steps
env int CMD_STOP 		= 0;
env int CMD_MOVE_FWD 	= 1;
env int CMD_MOVE_BWD 	= 2;
env int CMD_ROTATE_LEFT	= 4;
env int CMD_ROTATE_RIGHT= 8;  

//action status codes
env int ACTION_FREE 	= 0;
env int ACTION_ONGOING 	= 1;
env int ACTION_DONE 	= 2;
env int ACTION_CANCELLED= 3;

env int MAX_TOPIC_SUBSCRIBERS = 5;
env int MAX_TOPIC_PUBLISHERS = 2;
env int TOPIC_LASERSCAN = 1;
env int TOPIC_PATH = 2;

env int ACTION_FEEDBACK_RATE = 5000;

env int WCET_SERVICE_DEFAULT = 50;

env int MAX_ACTIONS = 2;	//buffer size
env int WCET_ACTION_NAME = 30000;

//diagonal movements
env int DiagonalMovement_Never = 0;
env int DiagonalMovement_OnlyWhenNoObstacles = 1;
env int DiagonalMovement_IfAtMostOneObstacle = 2;
env int DiagonalMovement_Always = 3;

reactiveclass Node(50) {
	knownrebecs {
		MapServer theMap;
	}
	statevars{
		byte rindex;	//numerical index of the robot, starting from 1
		int targetX, targetY;
		int rx, ry, rdir, velocity;
		int distance2target;
		int[101] obstacles;	//nearest obstacles in 8 possible directions
		int[101/*BUFFER_SIZE*/] moves;	//movement commands to tell the robot to move in a path, element 0 = size	
		int moveidx;	//current pointer in path
		int waits;
		int replans;
		int failures;
		int prevRedir;
		int default_velocity;
		boolean replanning;	//replan path if waiting too long
		boolean scan_before_move;
		int max_waiting_time;
		int[2/*MAX_ACTIONS*/] action_status;
	}
	
	Node (byte idx, int x, int y, int tx, int ty, int defvel, boolean isreplanning, boolean scanfirst, int maxwait){
		assertion(idx>=1,"Node index must be from 1");
		rindex = idx;
		rx = x; ry = y; rdir = DIR_N; targetX = x; targetY = y; distance2target = (int)INFINITY;
		default_velocity = defvel;
		velocity = 0;	
		moves[0]=0;
		for(int i=0;i<BUFFER_SIZE;i++) moves[i]=0;	//it is important to initialize all elements in an state variable array
		moveidx=0;
		waits=0; 
		replans = 0; prevRedir = -1; failures = 0;
		replanning = isreplanning;
		scan_before_move = scanfirst;
		max_waiting_time = maxwait;
		
		for(int i=0;i<BUFFER_SIZE;i++) obstacles[i]=0;
		
		for(int i=0;i<MAX_ACTIONS;i++) action_status[i]=ACTION_FREE;		
		setTarget(tx,ty);
	}
	
	void stop(boolean flushCmdPipe){
		velocity = 0;
		if (flushCmdPipe){
			for(int i=0;i<BUFFER_SIZE;i++) moves[i]=0;
			moveidx=0;
			waits=0;
		}
	}
	
	void resume(){
		if (moveidx < moves[0]){
			velocity = default_velocity;
			waits = 0;
			updateMovingStatus(!scan_before_move);
		}
	}
	
	int xy2idx(int ox,int oy){
		int x,sx,y,sy;	
		if (ox<0){
			sx=2;x=-ox;
		}else{
			sx=1;x=ox;		
		}
		if (oy<0){
			sy=2;y=-oy;
		}else{
			sy=1;y=oy;		
		}
		int ex = sx*1000 + x;
		int ey = sy*1000 + y;
		int idx = ey*10000 + ex;
		return idx;
	}
	
	//decode
	int[2] idx2xy(int idx){
		int ex = idx % 10000;
		int ey = (idx - ex) / 10000;
		int sx = (int)(ex/1000);
		int x = ex % 1000;
		int sy = (int)(ey/1000);
		int y = ey % 1000;
		if (sx==2) x=-x;
		if (sy==2) y=-y;
		int[2] ret;ret[0]=x;ret[1]=y;
		return ret;
	}	
	
	int cmp(double a,double b){
		return a>b?1:(a<b?-1:0);
	}
	
	//1.1 -> 2, -1.1 -> -2
	int round(double x){
		double dec = x/10;
		if (dec!=0) dec = dec>0?1:-1;
		return (int)x + dec;
	}
	
	int getTimeToStop(double v, double a){
		// a = delta v / delta t
		return a==0 ? 0 : round(v/a);
	}
	
	double getDistanceToStop(double v, double a){
		//v^2 - vo^2 = 2as
		return v==0 ? 0: 2*a / (v*v);
	}
	
	void setTarget(int x, int y){
		if (!(x==targetX && y==targetY)){
			stop(true);
			int xmin = SAFE_MARGIN;
			int xmax = MAP_ROWS-1 - SAFE_MARGIN;
			int ymin = SAFE_MARGIN;
			int ymax = MAP_COLS-1 - SAFE_MARGIN;
			if (x<xmin) x = xmin;
			if (x>xmax) x = xmax;
			if (y<ymin) y = ymin;
			if (y>ymax) y = ymax;
			targetX = x; targetY = y;
			int[8]blockdir = {0,0,0,0,0,0,0,0};
			theMap.generatePath(self,rx,ry,rdir,targetX,targetY,blockdir);		
		}
	}	

	int getNextDir(){
		if (moveidx>=moves[0]) return rdir;
		int[2] nxt = idx2xy(moves[moveidx+1]);
		int dx = nxt[0] - rx;
		int dy = nxt[1] - ry;
		int dir=0;
		if (dx==0) dir = dy>0?2:6;
		else if (dy==0) dir = dx>0?0:4;
		else if (dx*dy>0) dir = dx>0?1:5;
		else dir = dx<0?3:7;
		return dir;
		//return moves[moveidx+1];
	}
	
	int[2] getNeighborAtDir(int x, int y, int dir){
		//neighboring cells in 8 directions: e, ne, n, nw, w, sw, s, se
		int[8][2] nxt = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};
		dir%=8;
		if (dir<0)dir+=8;
		int[2] p ;
		p[0] = x + nxt[dir][0];
		p[1] = y + nxt[dir][1];
		return p;	
	}
	
	int[8][2] getNeighbors(int x, int y){
		//neighboring cells in 8 directions: e, ne, n, nw, w, sw, s, se
		int[8][2] nxt = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};
		int[8][2] p ;
		for(int i=0;i<8;i++){
			p[i][0] = x + nxt[i][0];
			p[i][1] = y + nxt[i][1];
		}
		return p;	
	}
	
	//move the robot N steps in the current direction, minus means moving back
	//stop = true, means the robot should stop after moving
	//@priority(2)
	boolean move(int dir,int steps,boolean stop){
		int[8][2] offsets = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};
		int dx = offsets[dir][0] * steps;
		int dy = offsets[dir][1] * steps;
		int x = rx + dx;
		int y = ry + dy;
		boolean moved = false;
		if (isInside(x,y)){
			rdir=dir;rx=x;ry=y; 
			moved=true;		
			theMap.updateRobotLocation(rindex,rx,ry,rdir,velocity);
			distance2target = round( odistance(rx,ry,targetX,targetY) );
			//boolean done = moves[0]>0 && moves[0]-moveidx<=2;
			//boolean onTarget = distance2target <= 2;
			//assertion(!(done && onTarget) ^ (done && onTarget),"the robot must be either in progress or reach target!");
			if (stop) stop(false);
		}
		return moved;
	}
	
	//rotate the robot N steps (1 step = 45 degrees), positive = counter-clockwise, negative = clockwise
	void rotate(int steps){
		rdir += steps;
		rdir %= 8;
		while (rdir<0) rdir+=8;
	}
	
	void rotate180(){
		rotate(4);
	}
	
	void rotateLeft(){
		rotate(1);
	}
	
	void rotateRight(){
		rotate(-1);
	}
	
	int getTargetDir(){
		int dx = cmp(targetX,rx);
		int dy = cmp(targetY,ry);
		int dir;
		if (dx==0) dir = dy>0?2:6;
		else if (dy==0) dir = dx>0?0:4;
		else if (dx*dy>0) dir = dx>0?1:5;
		else dir = dx<0?3:7;
		return dir;
	}
	
	void insertMoves(int at, int[11] extra_moves){
		int i,j;
		int[101] newmoves;
		for(i=0;i<BUFFER_SIZE;i++) newmoves[i]=0;
		newmoves[0] = moves[0]+extra_moves[0];
		if (at<0) at=0;
		if (at>moves[0]) at = moves[0]+1;
		for(i=1;i<=at;i++){
			newmoves[i] = moves[i];
		}
		for(i=1;i<=extra_moves[0];i++){
			newmoves[i] = extra_moves[i];
		}
		for(i=at+1;i<=moves[0];i++){
			newmoves[i] = moves[i];
		}
		for(i=0;i<BUFFER_SIZE;i++) moves[i]=newmoves[i];
	}
	
	boolean canMove(int dir){
		//robot boundary
		int xmax = round(ROBOT_LENGTH/2);
		int xmin = ROBOT_LENGTH - xmax;
		
		int ymax = round(ROBOT_BREADTH/2.0);
		int ymin = ROBOT_BREADTH - ymax;
		ymax += SAFE_MARGIN;
		ymin -= SAFE_MARGIN;
	
		double safe_distance = xmax + SAFE_MARGIN>0?SAFE_MARGIN:1;
		if (rdir % 2 != 0) safe_distance*=SQRT2;
		
		//double safe_distance = (rdir%2 ==0? xmax + SAFE_MARGIN : SQRT2*(xmax + SAFE_MARGIN));
		double howfar = INFINITY;
		int dx,dy,odir;
		/* obstacle direction relative to the robot:
				ymin	ymax
			3	|	2	|	1
		--------|-------|-------- xmax
			4	|		|	0 (+ rdir if convert to map direction)
		--------|-------|-------- xmin
			5	|	6	|	7
				|		|
		*/		
		
		int[2] next = getNeighborAtDir(rx,ry,dir);
		
		for(int i=1;i<=obstacles[0];i++){
			int[2] d= idx2xy(obstacles[i]);
			if (isInside(d[0],d[1])){
				double ofar = odistance(next[0],next[1],d[0],d[1]);
				if (ofar<howfar) howfar = ofar;
			}/*
			dx = d[0]>xmax ? 1 : (d[0]<xmin?-1:0);
			dy = d[1]>ymax ? 1 : (d[1]<ymin?-1:0);
			if (dx==0) odir = dy>0?2:6;
			else if (dy==0) odir = dx>0?0:4;
			else if (dx*dy>0) odir = dx>0?1:5;
			else odir = dx<0?3:7;
			if (odir == dir){
				if (isInside(d[0],d[1])){
					double ofar = odistance(next[0],next[1],d[0],d[1]);
					if (ofar<howfar) howfar = ofar;
				} else {
					
				}
			}			
			*/
		}
		boolean can = howfar > safe_distance;
		
		//if (rindex==4 && rx==48 && ry==29 && dir==6) assertion(can==false,"r4 can not move to [48,28] from [48,29]");
		
		return can;
	}
	
	@priority(1)
	msgsrv updateMovingStatus(boolean moveNext){
		int max_waiting_times = round(max_waiting_time / LASERSCAN_RATE);
		int xmax = round(ROBOT_LENGTH)/2 + STOP_ZONE;
		double safe_distance = (rdir%2 ==0? xmax : SQRT2*(xmax));
		//double safe_distance = odistance(0,0,round(ROBOT_LENGTH/2) + STOP_ZONE,0);
					
		//all moves have been queued
		if ( moveidx >= moves[0] ){
			stop(false);
		} else {
			rdir = getNextDir(); //rotate the robot to the next direction
			if (canMove(rdir)){
				if (velocity <= 0 ) velocity = default_velocity;
				int time_to_cross = round(1000/velocity);
				if (time_to_cross<1) time_to_cross = 1;
				moveidx++;			
				int wait = 0==(rdir % 2)? time_to_cross: round(SQRT2*time_to_cross);
				move(rdir,1,moveidx==moves[0]);
				waits = 0;		
				if (moveNext) updateMovingStatus(moveNext) after(wait);
			} else {
				//cannot move, stop if is moving, wait for obstacles to go away
				stop(false);
				waits++;
				//replan path if it has been waiting long enough
				if (waits>0 && (waits % max_waiting_times == 0)){
					int odir = rdir;			
					int odirleft = (rdir+1)%8;
					int odirright = ((rdir-1)+8)%8;
					if (replanning) {
						replans++;
						if (replans > 1){
							//move to another direction with farthest obstacle
							int redir=-1;
							if (true){
								int backdir = (rdir+4) % 8;
								//redir = getTargetDir();
								redir = ?(0,1,2,3,4,5,6,7,8);
								//pick a random direction that is not the same or reverse as current dir, and has space to move
								while (redir == odir || redir == odirleft || redir == odirright || redir == prevRedir || !canMove(redir)){
									redir = ?(0,1,2,3,4,5,6,7,8);
								}
								int steps = STOP_ZONE+1;//?(1,2,3,4);							
								for(int i=0;i<steps;i++) {
									if (canMove(redir))	move(redir,1,false); else break;
								}						
							} else {
							/*
								int steps = ?(1,2,3,4);							
								for(int j=0;j<steps;j++){
									int most=-1;								
									for(int i=0;i<8;i++){
										if (i!=rdir && i!=prevRedir && distances[i]>most) {most=distances[i];redir=i;}									
									}
									if (canMove(redir))	move(redir,1,false);
								}
								*/
							}
							prevRedir = redir;
							replans = 0;
						}
						stop(true);//clear existing path, request a new one
						int[8]blockdir={3,odir,odirleft,odirright,0,0,0,0};
						theMap.generatePath(self,rx,ry,rdir,targetX,targetY,blockdir);
					}
				}
			}
		}
	}
	
	double abs(double x){
		return x>=0?x:-x;
	}
	
		//Euclide distance
	double edistance(double x1, double y1, double x2, double y2){
		return sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
	}
	
	//Manhattan distance
	double mdistance(double x1, double y1, double x2, double y2){
		return abs(x2-x1) + abs(y2-y1);
	}
	
	//Octile distance
	double odistance(double x1, double y1, double x2, double y2){
		double dx = abs(x2-x1);
		double dy = abs(y2-y1);
		double f = SQRT2 - 1;
		return (dx < dy) ? f * dx + dy : f * dy + dx;	
	}
	
	double cdistance(double x1, double y1, double x2, double y2){
		double dx = abs(x2-x1);
		double dy = abs(y2-y1);
		return dx>dy?dx:dy;
	}
	
	int normalizeDir(int dir){
		dir%=8;
		if (dir<0) dir+=8;
		return dir;
	}
	
	boolean isInside(int x, int y){
		return x>=0 && x<MAP_ROWS && y>=0 && y<MAP_COLS;
	}
/*
	//update distances to current obstacles	
	void updateDistances(){
		for(int i=0;i<8;i++) {
			int[2] p = idx2xy(obstacles[i]);
			distances[i] = isInside(p[0],p[1])?round(odistance(rx,ry,p[0],p[1])):(int)INFINITY;
		}
		if (rx==0){
			distances[3] = distances[4] = distances[5] = 0;
		}else if (rx==MAP_ROWS-1){
			distances[7] = distances[1] = distances[0] = 0;
		}
		if (ry==0){
			distances[5] = distances[6] = distances[7] = 0;			
		}else if (ry==MAP_COLS-1){
			distances[1] = distances[2] = distances[3] = 0;
		}
	}
*/	
	//scandata = array of (x,y) of obstacles relative to the robot
	//angles = array of laser ray angle index (*ANGLE_INC to get the angle value, relative to the robot's movement axis) 
	@priority(3)
	msgsrv onLaserScan(int[101] scandata, int[101] angles){
	
		int max_range = round(ROBOT_LENGTH/2) + STOP_ZONE;
		
		for(int i=0;i<BUFFER_SIZE;i++) obstacles[i]=0;

		for(int i=1;i<=scandata[0];i++){
			int[2] d = idx2xy(scandata[i]);	//(x,y) in map coordinates		
			int howfar = isInside(d[0],d[1]) ? round(odistance(rx,ry,d[0],d[1])) : (int)INFINITY;
			if (howfar <= max_range){
				obstacles[0]++;
				obstacles[obstacles[0]] = scandata[i];
			}
		}
		updateMovingStatus(!scan_before_move);	
	}
	
	@priority(10)
	msgsrv onNewPath(int[101/*BUFFER_SIZE*/] path){
		stop(true);
		if (path[0]>0){
			for(int i=0;i<BUFFER_SIZE;i++) moves[i] = path[i];
			/*
			int[2] current;
			int[2] nxt;
			current = idx2xy(path[1]);
			moves[0]=0;
			moveidx=0;
			for(int i=2;i<=path[0];i++){
				nxt = idx2xy(path[i]);
				int dx = nxt[0] - current[0];
				int dy = nxt[1] - current[1];
				int dir=0;
				if (dx==0) dir = dy>0?2:6;
				else if (dy==0) dir = dx>0?0:4;
				else if (dx*dy>0) dir = dx>0?1:5;
				else dir = dx<0?3:7;
				moves[0]++;
				moves[moves[0]] = dir;
				current[0] = nxt[0];
				current[1] = nxt[1];
			}
			*/
			//start moving
			velocity = default_velocity;
			if (!scan_before_move) updateMovingStatus(true);
		} else {
			//path not found, what to do next???
			failures++;
			if (failures>2){
				assertion(false,"the robot seems to get stuck");
			} else if (replanning) {
				int odir = rdir;
				int odirleft = (odir+1)%8;
				int odirright = (odir-1+8)%8;
				//rotateRight();move(rdir,2,false);rotateLeft();move(rdir,STOP_ZONE,false);rotateLeft();move(rdir,2,false);
				//int redir = rdir;
				int backdir = (rdir+4) % 8;
				//int redir = backdir;//getTargetDir();
				int redir = ?(0,1,2,3,4,5,6,7,8);
				//pick a random direction that is not the same or reverse as current dir, and has space to move
				while (redir == odir || redir == odirleft || redir == odirright || redir == prevRedir || !canMove(redir)){
					redir = ?(0,1,2,3,4,5,6,7,8);
				}
				int steps = STOP_ZONE+1;//?(1,2,3,4);							
				for(int i=0;i<steps;i++) {
					if (canMove(redir))	move(redir,1,false); else break;
				}
				prevRedir = redir;
				int[8]blockdir = {3,odir,odirleft,odirright,0,0,0,0};
				theMap.generatePath(self,rx,ry,rdir,targetX,targetY,blockdir);
			}
		}
	}
		
	msgsrv onTopicMessage(int topicName, int[10] topicMessage){
		
	}

	msgsrv onServiceRequest(int serviceName, byte[255] serviceParams){		
		delay(WCET_SERVICE_DEFAULT);
		((Node)sender).onServiceDone(serviceName,1);
	}
	
	msgsrv onServiceDone(int serviceName,int serviceResult){
	}
	
	msgsrv doAction(int actionName, int[10] actionParams, int feedback_rate, int max_time){
		assertion(actionName>=0 && actionName<=MAX_ACTIONS, "action code is out of range");
		if (action_status[actionName] != ACTION_ONGOING){
		
			action_status[actionName] = ACTION_ONGOING;
			
			feedbackAction((Node) sender, actionName, feedback_rate);
			
			delay(WCET_ACTION_NAME);
			
			int actionResult = 1;
			
			if (action_status[actionName]!= ACTION_CANCELLED){
				action_status[actionName] = ACTION_DONE;		
				((Node)sender).onActionDone(actionName,actionResult);
			}
			
		} else {
			cancelAction(actionName);	//cancel current action
			doAction(actionName,actionParams,feedback_rate,max_time);			
		}
	}
	
	msgsrv feedbackAction(Node n,int actionName,int rate){
		if (action_status[actionName] == ACTION_ONGOING){
			int[10] data;
			n.onActionFeedback(actionName,data);
			feedbackAction(n,actionName,rate) after(rate);
		}
	}
	
	msgsrv cancelAction(int actionName){
		action_status[actionName] = ACTION_CANCELLED;
		self.onActionCancelled(actionName);
	}
		
	msgsrv onActionFeedback(int actionName,int[10] data){
		
	}
	
	msgsrv onActionDone(int actionName, int actionResult){
	
	}
	
	msgsrv onActionCancelled(int actionName){
	
	}
	
}

reactiveclass Topic(20) {
	statevars{
		int topicName;
		Node[5] subscribers;
		int countSubscribers;
	}
	
	Topic(int t){
		topicName = t;
		countSubscribers=0;
	}
	
	msgsrv subscribe(){
		if (countSubscribers<5){
			subscribers[countSubscribers]=(Node)sender;
			countSubscribers++;		
		}
	}
	
	msgsrv unsubscribe(){
		Node n = (Node)sender;
		for(int i=0;i<countSubscribers;i++){
			if (subscribers[i] == n) {subscribers[i]=null;break;}
		}
	}
	
	msgsrv send(int[10] topicMessage){
		for(int i=0;i<countSubscribers;i++){
			if (subscribers[i]!=null)
				subscribers[i].onTopicMessage(topicName,topicMessage);
		}
	}
	
	msgsrv perodic_send(int rate){
		int[10] topicMessage;
		send(topicMessage);	
		perodic_send(rate) after(rate);
	}
}

//generic action server for a node
reactiveclass ActionServer(20){
	knownrebecs{
		
	}
	
	statevars{
		Node node;
		int[5] action_status;
	}
	
	ActionServer(Node n){
		node = n;
	}
	
	msgsrv doAction(int actionName, int feedback_rate, int max_time, int[10] actionParams){
		assertion(actionName>=0 && actionName<=10,"action code is out of range");
		//status = free, cancelled, done
		if (action_status[actionName] != ACTION_ONGOING){
		
			action_status[actionName] = ACTION_ONGOING;
			
			feedbackAction(actionName, feedback_rate);
			
			delay(WCET_ACTION_NAME);
			
			if (action_status[actionName]!= ACTION_CANCELLED){
				action_status[actionName] = ACTION_DONE;
				node.onActionDone(actionName,1);
			}
			
		} else {
			cancelAction(actionName);	//cancel current ongoing action
			doAction(actionName,feedback_rate,max_time,actionParams);			
		}
	}
	
	msgsrv cancelAction(int actionName){
		assertion(actionName>=0 && actionName<=MAX_ACTIONS,"action code is out of range");
		action_status[actionName] = ACTION_CANCELLED;
		node.onActionCancelled(actionName);
	}
	
	msgsrv feedbackAction(int actionName,int feedback_rate){
		if (action_status[actionName] == ACTION_ONGOING){
			int[10] data;
			node.onActionFeedback(actionName,data);
			feedbackAction(actionName, feedback_rate) after(feedback_rate);
		}
	}
	
}


reactiveclass MapServer(50) {
	knownrebecs{
		Node r1;
		Node r2;
		Node r3;
		Node r4;
		Node r5;		
	}
	statevars{
		int[21] rloc; //#0 = counter, [1,2,3,4] = [x,y,dir,isMoving] of each robot
	}
		
	MapServer(int rcount){
		int max = 5;//(int)((BUFFER_SIZE-1)/4);
		assertion(rcount>=1 && rcount<=max,"Number of robots is out of range");
		rloc[0] = rcount;
		for(int i=0;i<max;i++) {
			rloc[4*i+1]=-1;
			rloc[4*i+2]=-1;
			rloc[4*i+3]=0;
			rloc[4*i+4]=0;
		}
		
		scanObstacles(r1,1,LASERSCAN_RATE,FIELD_OF_VIEW,LASERSCAN_MAX_DISTANCE);
		scanObstacles(r2,2,LASERSCAN_RATE,FIELD_OF_VIEW,LASERSCAN_MAX_DISTANCE);
		scanObstacles(r3,3,LASERSCAN_RATE,FIELD_OF_VIEW,LASERSCAN_MAX_DISTANCE);
		scanObstacles(r4,4,LASERSCAN_RATE,FIELD_OF_VIEW,LASERSCAN_MAX_DISTANCE);
		scanObstacles(r5,5,LASERSCAN_RATE,FIELD_OF_VIEW,LASERSCAN_MAX_DISTANCE);
	}
	
	//helper math functions	
	double pow(double base, int n){
		double x = 1; 
		for(int i=0;i<n;i++) x*=base;
		return x;
	}
	
	double abs(double x){
		return x>=0?x:-x;
	}
	
	int sign(double x){
		return x>0?1:(x<0?-1:0);
	}
	
	double min(double a, double b){
		return a<b?a:b;
	}
	
	double max(double a, double b){
		return a>b?a:b;
	}
	
	//1.1 -> 2, -1.1 -> -2
	int round(double x){
		double dec = x/10;
		if (dec!=0) dec = dec>0?1:-1;
		return (int)x + dec;
	}
	
	int floor(double x){
		return (int)x;
	}
	
	boolean between(double x, double x1, double x2){
		return ( sign(x-x1)*sign(x-x2) )<=0;
	}
	
	boolean isInside(int x, int y){
		return x>=0 && x<MAP_ROWS && y>=0 && y<MAP_COLS;
	}		
	
	double deg2rad(double a){
		return a * PI / 180;
	}
	
	double rad2deg(double a){
		return a * 180 / PI;
	}
	
	int getAngleIndex(double a){
		int i = round(a/ANGLE_INC);
		return i;
	}
	
	double sqrt(double number) {
	    double start = 0;
	    double end = number;
	    double mid = (start + end) / 2;
	    while (end - start > EPSILON) {
	        if (mid * mid > number) {
	            end = mid;
	        } else {
	            start = mid;
	        }
	        mid = (start + end) / 2;
	    }	
	    return mid;
	}	
	
	//Euclide distance
	double edistance(double x1, double y1, double x2, double y2){
		return sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
	}
	
	//Manhattan distance
	double mdistance(double x1, double y1, double x2, double y2){
		return abs(x2-x1) + abs(y2-y1);
	}
	
	//Octile distance
	double odistance(double x1, double y1, double x2, double y2){
		double dx = x2-x1;
		double dy = y2-y1;
		double f = SQRT2 - 1;
		return (dx < dy) ? f * dx + dy : f * dy + dx;	
	}
	
	double cdistance(double x1, double y1, double x2, double y2){
		double dx = x2-x1;
		double dy = y2-y1;
		return dx>dy?dx:dy;
	}
	
	int getAngleFromDir(int dir){
		dir %= 8;
		if (dir<0) dir+=8;
		return 45*dir;
	}
	
	//x' = (x - a) * cos(theta) - (y - b) * sin(theta) 
	//y' = (x - a) * sin(theta) + (y - b) * cos(theta)
	//theta = 0,45,90,135,180,235,270,360
	int[2] getNewCoord(int x, int y, int a, int b, int dir){
		dir = dir % 8;
		if (dir<0) dir+=8;
		
		//theta = 0,45,90,135,180,235,270,360
		//cos = x, sin = y, tan = y/x
		
		//use ENV for these constant arrays will cause the model not compilable, don't know the reason
		double[8] sins = {0,SIN45,1,SIN45,0,-SIN45,-1,-SIN45};
		double[8] coss = {1,SIN45,0,-SIN45,-1,-SIN45,0,SIN45};		

		int[2] p;
		p[0] = round((x - a)*coss[dir] - (y - b)*sins[dir]);
		p[1] = round((x - a)*sins[dir] + (y - b)*coss[dir]);
		
		return p;
	}
	
	//pre-calculate values of angle steps (angle value in degree, cos, sin, tan) 
	double[4] getAngleCalc(int i){
	assertion(ANGLE_INC==2,"only computed for angle increment = 2");
double[724] a;
a[0]=0.0;a[1]=1.0000;a[2]=0.0000;a[3]=0.0000;a[4]=2.0;a[5]=0.9994;a[6]=0.0349;a[7]=0.0349;a[8]=4.0;a[9]=0.9976;a[10]=0.0698;a[11]=0.0699;a[12]=6.0;a[13]=0.9945;a[14]=0.1045;a[15]=0.1051;a[16]=8.0;a[17]=0.9903;a[18]=0.1392;a[19]=0.1405;a[20]=10.0;a[21]=0.9848;a[22]=0.1736;a[23]=0.1763;a[24]=12.0;a[25]=0.9781;a[26]=0.2079;a[27]=0.2126;a[28]=14.0;a[29]=0.9703;a[30]=0.2419;a[31]=0.2493;a[32]=16.0;a[33]=0.9613;a[34]=0.2756;a[35]=0.2867;a[36]=18.0;a[37]=0.9511;a[38]=0.3090;a[39]=0.3249;a[40]=20.0;a[41]=0.9397;a[42]=0.3420;a[43]=0.3640;a[44]=22.0;a[45]=0.9272;a[46]=0.3746;a[47]=0.4040;a[48]=24.0;a[49]=0.9135;a[50]=0.4067;a[51]=0.4452;a[52]=26.0;a[53]=0.8988;a[54]=0.4384;a[55]=0.4877;a[56]=28.0;a[57]=0.8829;a[58]=0.4695;a[59]=0.5317;a[60]=30.0;a[61]=0.8660;a[62]=0.5000;a[63]=0.5774;a[64]=32.0;a[65]=0.8480;a[66]=0.5299;a[67]=0.6249;a[68]=34.0;a[69]=0.8290;a[70]=0.5592;a[71]=0.6745;a[72]=36.0;a[73]=0.8090;a[74]=0.5878;a[75]=0.7265;a[76]=38.0;a[77]=0.7880;a[78]=0.6157;a[79]=0.7813;a[80]=40.0;a[81]=0.7660;a[82]=0.6428;a[83]=0.8391;a[84]=42.0;a[85]=0.7431;a[86]=0.6691;a[87]=0.9004;a[88]=44.0;a[89]=0.7193;a[90]=0.6947;a[91]=0.9657;a[92]=46.0;a[93]=0.6947;a[94]=0.7193;a[95]=1.0355;a[96]=48.0;a[97]=0.6691;a[98]=0.7431;a[99]=1.1106;a[100]=50.0;a[101]=0.6428;a[102]=0.7660;a[103]=1.1918;a[104]=52.0;a[105]=0.6157;a[106]=0.7880;a[107]=1.2799;a[108]=54.0;a[109]=0.5878;a[110]=0.8090;a[111]=1.3764;a[112]=56.0;a[113]=0.5592;a[114]=0.8290;a[115]=1.4826;a[116]=58.0;a[117]=0.5299;a[118]=0.8480;a[119]=1.6003;a[120]=60.0;a[121]=0.5000;a[122]=0.8660;a[123]=1.7321;a[124]=62.0;a[125]=0.4695;a[126]=0.8829;a[127]=1.8807;a[128]=64.0;a[129]=0.4384;a[130]=0.8988;a[131]=2.0503;a[132]=66.0;a[133]=0.4067;a[134]=0.9135;a[135]=2.2460;a[136]=68.0;a[137]=0.3746;a[138]=0.9272;a[139]=2.4751;a[140]=70.0;a[141]=0.3420;a[142]=0.9397;a[143]=2.7475;a[144]=72.0;a[145]=0.3090;a[146]=0.9511;a[147]=3.0777;a[148]=74.0;a[149]=0.2756;a[150]=0.9613;a[151]=3.4874;a[152]=76.0;a[153]=0.2419;a[154]=0.9703;a[155]=4.0108;a[156]=78.0;a[157]=0.2079;a[158]=0.9781;a[159]=4.7046;a[160]=80.0;a[161]=0.1736;a[162]=0.9848;a[163]=5.6713;a[164]=82.0;a[165]=0.1392;a[166]=0.9903;a[167]=7.1154;a[168]=84.0;a[169]=0.1045;a[170]=0.9945;a[171]=9.5144;a[172]=86.0;a[173]=0.0698;a[174]=0.9976;a[175]=14.3007;a[176]=88.0;a[177]=0.0349;a[178]=0.9994;a[179]=28.6363;a[180]=90.0;a[181]=0.0000;a[182]=1.0000;a[183]=16331239353195370.0000;a[184]=92.0;a[185]=-0.0349;a[186]=0.9994;a[187]=-28.6363;a[188]=94.0;a[189]=-0.0698;a[190]=0.9976;a[191]=-14.3007;a[192]=96.0;a[193]=-0.1045;a[194]=0.9945;a[195]=-9.5144;a[196]=98.0;a[197]=-0.1392;a[198]=0.9903;a[199]=-7.1154;a[200]=100.0;a[201]=-0.1736;a[202]=0.9848;a[203]=-5.6713;a[204]=102.0;a[205]=-0.2079;a[206]=0.9781;a[207]=-4.7046;a[208]=104.0;a[209]=-0.2419;a[210]=0.9703;a[211]=-4.0108;a[212]=106.0;a[213]=-0.2756;a[214]=0.9613;a[215]=-3.4874;a[216]=108.0;a[217]=-0.3090;a[218]=0.9511;a[219]=-3.0777;a[220]=110.0;a[221]=-0.3420;a[222]=0.9397;a[223]=-2.7475;a[224]=112.0;a[225]=-0.3746;a[226]=0.9272;a[227]=-2.4751;a[228]=114.0;a[229]=-0.4067;a[230]=0.9135;a[231]=-2.2460;a[232]=116.0;a[233]=-0.4384;a[234]=0.8988;a[235]=-2.0503;a[236]=118.0;a[237]=-0.4695;a[238]=0.8829;a[239]=-1.8807;a[240]=120.0;a[241]=-0.5000;a[242]=0.8660;a[243]=-1.7321;a[244]=122.0;a[245]=-0.5299;a[246]=0.8480;a[247]=-1.6003;a[248]=124.0;a[249]=-0.5592;a[250]=0.8290;a[251]=-1.4826;a[252]=126.0;a[253]=-0.5878;a[254]=0.8090;a[255]=-1.3764;a[256]=128.0;a[257]=-0.6157;a[258]=0.7880;a[259]=-1.2799;a[260]=130.0;a[261]=-0.6428;a[262]=0.7660;a[263]=-1.1918;a[264]=132.0;a[265]=-0.6691;a[266]=0.7431;a[267]=-1.1106;a[268]=134.0;a[269]=-0.6947;a[270]=0.7193;a[271]=-1.0355;a[272]=136.0;a[273]=-0.7193;a[274]=0.6947;a[275]=-0.9657;a[276]=138.0;a[277]=-0.7431;a[278]=0.6691;a[279]=-0.9004;a[280]=140.0;a[281]=-0.7660;a[282]=0.6428;a[283]=-0.8391;a[284]=142.0;a[285]=-0.7880;a[286]=0.6157;a[287]=-0.7813;a[288]=144.0;a[289]=-0.8090;a[290]=0.5878;a[291]=-0.7265;a[292]=146.0;a[293]=-0.8290;a[294]=0.5592;a[295]=-0.6745;a[296]=148.0;a[297]=-0.8480;a[298]=0.5299;a[299]=-0.6249;a[300]=150.0;a[301]=-0.8660;a[302]=0.5000;a[303]=-0.5774;a[304]=152.0;a[305]=-0.8829;a[306]=0.4695;a[307]=-0.5317;a[308]=154.0;a[309]=-0.8988;a[310]=0.4384;a[311]=-0.4877;a[312]=156.0;a[313]=-0.9135;a[314]=0.4067;a[315]=-0.4452;a[316]=158.0;a[317]=-0.9272;a[318]=0.3746;a[319]=-0.4040;a[320]=160.0;a[321]=-0.9397;a[322]=0.3420;a[323]=-0.3640;a[324]=162.0;a[325]=-0.9511;a[326]=0.3090;a[327]=-0.3249;a[328]=164.0;a[329]=-0.9613;a[330]=0.2756;a[331]=-0.2867;a[332]=166.0;a[333]=-0.9703;a[334]=0.2419;a[335]=-0.2493;a[336]=168.0;a[337]=-0.9781;a[338]=0.2079;a[339]=-0.2126;a[340]=170.0;a[341]=-0.9848;a[342]=0.1736;a[343]=-0.1763;a[344]=172.0;a[345]=-0.9903;a[346]=0.1392;a[347]=-0.1405;a[348]=174.0;a[349]=-0.9945;a[350]=0.1045;a[351]=-0.1051;a[352]=176.0;a[353]=-0.9976;a[354]=0.0698;a[355]=-0.0699;a[356]=178.0;a[357]=-0.9994;a[358]=0.0349;a[359]=-0.0349;a[360]=180.0;a[361]=-1.0000;a[362]=0.0000;a[363]=0.0000;a[364]=182.0;a[365]=-0.9994;a[366]=-0.0349;a[367]=0.0349;a[368]=184.0;a[369]=-0.9976;a[370]=-0.0698;a[371]=0.0699;a[372]=186.0;a[373]=-0.9945;a[374]=-0.1045;a[375]=0.1051;a[376]=188.0;a[377]=-0.9903;a[378]=-0.1392;a[379]=0.1405;a[380]=190.0;a[381]=-0.9848;a[382]=-0.1736;a[383]=0.1763;a[384]=192.0;a[385]=-0.9781;a[386]=-0.2079;a[387]=0.2126;a[388]=194.0;a[389]=-0.9703;a[390]=-0.2419;a[391]=0.2493;a[392]=196.0;a[393]=-0.9613;a[394]=-0.2756;a[395]=0.2867;a[396]=198.0;a[397]=-0.9511;a[398]=-0.3090;a[399]=0.3249;a[400]=200.0;a[401]=-0.9397;a[402]=-0.3420;a[403]=0.3640;
a[404]=202.0;a[405]=-0.9272;a[406]=-0.3746;a[407]=0.4040;a[408]=204.0;a[409]=-0.9135;a[410]=-0.4067;a[411]=0.4452;a[412]=206.0;a[413]=-0.8988;a[414]=-0.4384;a[415]=0.4877;a[416]=208.0;a[417]=-0.8829;a[418]=-0.4695;a[419]=0.5317;a[420]=210.0;a[421]=-0.8660;a[422]=-0.5000;a[423]=0.5774;a[424]=212.0;a[425]=-0.8480;a[426]=-0.5299;a[427]=0.6249;a[428]=214.0;a[429]=-0.8290;a[430]=-0.5592;a[431]=0.6745;a[432]=216.0;a[433]=-0.8090;a[434]=-0.5878;a[435]=0.7265;a[436]=218.0;a[437]=-0.7880;a[438]=-0.6157;a[439]=0.7813;a[440]=220.0;a[441]=-0.7660;a[442]=-0.6428;a[443]=0.8391;a[444]=222.0;a[445]=-0.7431;a[446]=-0.6691;a[447]=0.9004;a[448]=224.0;a[449]=-0.7193;a[450]=-0.6947;a[451]=0.9657;a[452]=226.0;a[453]=-0.6947;a[454]=-0.7193;a[455]=1.0355;a[456]=228.0;a[457]=-0.6691;a[458]=-0.7431;a[459]=1.1106;a[460]=230.0;a[461]=-0.6428;a[462]=-0.7660;a[463]=1.1918;a[464]=232.0;a[465]=-0.6157;a[466]=-0.7880;a[467]=1.2799;a[468]=234.0;a[469]=-0.5878;a[470]=-0.8090;a[471]=1.3764;a[472]=236.0;a[473]=-0.5592;a[474]=-0.8290;a[475]=1.4826;a[476]=238.0;a[477]=-0.5299;a[478]=-0.8480;a[479]=1.6003;a[480]=240.0;a[481]=-0.5000;a[482]=-0.8660;a[483]=1.7321;a[484]=242.0;a[485]=-0.4695;a[486]=-0.8829;a[487]=1.8807;a[488]=244.0;a[489]=-0.4384;a[490]=-0.8988;a[491]=2.0503;a[492]=246.0;a[493]=-0.4067;a[494]=-0.9135;a[495]=2.2460;a[496]=248.0;a[497]=-0.3746;a[498]=-0.9272;a[499]=2.4751;a[500]=250.0;a[501]=-0.3420;a[502]=-0.9397;a[503]=2.7475;a[504]=252.0;a[505]=-0.3090;a[506]=-0.9511;a[507]=3.0777;a[508]=254.0;a[509]=-0.2756;a[510]=-0.9613;a[511]=3.4874;a[512]=256.0;a[513]=-0.2419;a[514]=-0.9703;a[515]=4.0108;a[516]=258.0;a[517]=-0.2079;a[518]=-0.9781;a[519]=4.7046;a[520]=260.0;a[521]=-0.1736;a[522]=-0.9848;a[523]=5.6713;a[524]=262.0;a[525]=-0.1392;a[526]=-0.9903;a[527]=7.1154;a[528]=264.0;a[529]=-0.1045;a[530]=-0.9945;a[531]=9.5144;a[532]=266.0;a[533]=-0.0698;a[534]=-0.9976;a[535]=14.3007;a[536]=268.0;a[537]=-0.0349;a[538]=-0.9994;a[539]=28.6363;a[540]=270.0;a[541]=0.0000;a[542]=-1.0000;a[543]=5443746451065123.0000;a[544]=272.0;a[545]=0.0349;a[546]=-0.9994;a[547]=-28.6363;a[548]=274.0;a[549]=0.0698;a[550]=-0.9976;a[551]=-14.3007;a[552]=276.0;a[553]=0.1045;a[554]=-0.9945;a[555]=-9.5144;a[556]=278.0;a[557]=0.1392;a[558]=-0.9903;a[559]=-7.1154;a[560]=280.0;a[561]=0.1736;a[562]=-0.9848;a[563]=-5.6713;a[564]=282.0;a[565]=0.2079;a[566]=-0.9781;a[567]=-4.7046;a[568]=284.0;a[569]=0.2419;a[570]=-0.9703;a[571]=-4.0108;a[572]=286.0;a[573]=0.2756;a[574]=-0.9613;a[575]=-3.4874;a[576]=288.0;a[577]=0.3090;a[578]=-0.9511;a[579]=-3.0777;a[580]=290.0;a[581]=0.3420;a[582]=-0.9397;a[583]=-2.7475;a[584]=292.0;a[585]=0.3746;a[586]=-0.9272;a[587]=-2.4751;a[588]=294.0;a[589]=0.4067;a[590]=-0.9135;a[591]=-2.2460;a[592]=296.0;a[593]=0.4384;a[594]=-0.8988;a[595]=-2.0503;a[596]=298.0;a[597]=0.4695;a[598]=-0.8829;a[599]=-1.8807;a[600]=300.0;a[601]=0.5000;a[602]=-0.8660;a[603]=-1.7321;a[604]=302.0;a[605]=0.5299;a[606]=-0.8480;a[607]=-1.6003;a[608]=304.0;a[609]=0.5592;a[610]=-0.8290;a[611]=-1.4826;a[612]=306.0;a[613]=0.5878;a[614]=-0.8090;a[615]=-1.3764;a[616]=308.0;a[617]=0.6157;a[618]=-0.7880;a[619]=-1.2799;a[620]=310.0;a[621]=0.6428;a[622]=-0.7660;a[623]=-1.1918;a[624]=312.0;a[625]=0.6691;a[626]=-0.7431;a[627]=-1.1106;a[628]=314.0;a[629]=0.6947;a[630]=-0.7193;a[631]=-1.0355;a[632]=316.0;a[633]=0.7193;a[634]=-0.6947;a[635]=-0.9657;a[636]=318.0;a[637]=0.7431;a[638]=-0.6691;a[639]=-0.9004;a[640]=320.0;a[641]=0.7660;a[642]=-0.6428;a[643]=-0.8391;a[644]=322.0;a[645]=0.7880;a[646]=-0.6157;a[647]=-0.7813;a[648]=324.0;a[649]=0.8090;a[650]=-0.5878;a[651]=-0.7265;a[652]=326.0;a[653]=0.8290;a[654]=-0.5592;a[655]=-0.6745;a[656]=328.0;a[657]=0.8480;a[658]=-0.5299;a[659]=-0.6249;a[660]=330.0;a[661]=0.8660;a[662]=-0.5000;a[663]=-0.5774;a[664]=332.0;a[665]=0.8829;a[666]=-0.4695;a[667]=-0.5317;a[668]=334.0;a[669]=0.8988;a[670]=-0.4384;a[671]=-0.4877;a[672]=336.0;a[673]=0.9135;a[674]=-0.4067;a[675]=-0.4452;a[676]=338.0;a[677]=0.9272;a[678]=-0.3746;a[679]=-0.4040;a[680]=340.0;a[681]=0.9397;a[682]=-0.3420;a[683]=-0.3640;a[684]=342.0;a[685]=0.9511;a[686]=-0.3090;a[687]=-0.3249;a[688]=344.0;a[689]=0.9613;a[690]=-0.2756;a[691]=-0.2867;a[692]=346.0;a[693]=0.9703;a[694]=-0.2419;a[695]=-0.2493;a[696]=348.0;a[697]=0.9781;a[698]=-0.2079;a[699]=-0.2126;a[700]=350.0;a[701]=0.9848;a[702]=-0.1736;a[703]=-0.1763;a[704]=352.0;a[705]=0.9903;a[706]=-0.1392;a[707]=-0.1405;a[708]=354.0;a[709]=0.9945;a[710]=-0.1045;a[711]=-0.1051;a[712]=356.0;a[713]=0.9976;a[714]=-0.0698;a[715]=-0.0699;a[716]=358.0;a[717]=0.9994;a[718]=-0.0349;a[719]=-0.0349;a[720]=360.0;a[721]=1.0000;a[722]=0.0000;a[723]=0.0000;
		int max = (int)(360 / ANGLE_INC);
		if (i<0) i+=max;
		int j = 4*i;
		double[4] m = {a[j],a[j+1],a[j+2],a[j+3]};
		return m;
	}
			
	//modelling obstacle detection with laser beams	
	@priority(1)
	msgsrv scanObstacles(Node n,int rindex,int rate,int fov,int max_distance){	
		int i,j,k,rx,ry,rdir;
		
		//prepare scan data here --> list of nearest obstacles around the robot, return (X,Y) coordinates to the robot's axises
		int[101] scandata;
		for(i=0;i<101;i++) scandata[i]=0;
		int[101] angles;
		for(i=0;i<101;i++) angles[i]=0;
		
//define the occupancy grid
boolean[50/*MAP_ROWS*/][50/*MAP_COLS*/] map;
for(i=0;i<MAP_ROWS;i++)for(j=0;j<MAP_COLS;j++)map[i][j]=false;		
map[8][18]=true;map[8][19]=true;map[8][20]=true;map[8][21]=true;map[8][22]=true;map[9][18]=true;map[9][19]=true;map[9][20]=true;map[9][21]=true;map[9][22]=true;map[10][18]=true;map[10][19]=true;map[10][20]=true;map[10][21]=true;map[10][22]=true;map[11][18]=true;map[11][19]=true;map[11][20]=true;map[11][21]=true;map[11][22]=true;map[12][18]=true;map[12][19]=true;map[12][20]=true;map[12][21]=true;map[12][22]=true;map[13][18]=true;map[13][19]=true;map[13][20]=true;map[13][21]=true;map[13][22]=true;map[14][18]=true;map[14][19]=true;map[14][20]=true;map[14][21]=true;map[14][22]=true;map[15][18]=true;map[15][19]=true;map[15][20]=true;map[15][21]=true;map[15][22]=true;map[16][18]=true;map[16][19]=true;map[16][20]=true;map[16][21]=true;map[16][22]=true;map[17][18]=true;map[17][19]=true;map[17][20]=true;map[17][21]=true;map[17][22]=true;map[18][18]=true;map[18][19]=true;map[18][20]=true;map[18][21]=true;map[18][22]=true;map[19][18]=true;map[19][19]=true;map[19][20]=true;map[19][21]=true;map[19][22]=true;map[20][18]=true;map[20][19]=true;map[20][20]=true;map[20][21]=true;map[20][22]=true;map[21][18]=true;map[21][19]=true;map[21][20]=true;map[21][21]=true;map[21][22]=true;map[22][18]=true;map[22][19]=true;map[22][20]=true;map[22][21]=true;map[22][22]=true;map[23][18]=true;map[23][19]=true;map[23][20]=true;map[23][21]=true;map[23][22]=true;map[24][18]=true;map[24][19]=true;map[24][20]=true;map[24][21]=true;map[24][22]=true;map[25][18]=true;map[25][19]=true;map[25][20]=true;map[25][21]=true;map[25][22]=true;map[26][19]=true;map[26][20]=true;map[26][21]=true;map[30][33]=true;map[30][34]=true;map[30][35]=true;map[30][36]=true;map[30][37]=true;map[30][38]=true;map[30][39]=true;map[30][40]=true;map[30][41]=true;map[31][33]=true;map[31][34]=true;map[31][35]=true;map[31][36]=true;map[31][37]=true;map[31][38]=true;map[31][39]=true;map[31][40]=true;map[31][41]=true;map[32][33]=true;map[32][34]=true;map[32][35]=true;map[32][36]=true;map[32][37]=true;map[32][38]=true;map[32][39]=true;map[32][40]=true;map[32][41]=true;map[33][4]=true;map[33][5]=true;map[33][6]=true;map[33][7]=true;map[33][8]=true;map[33][9]=true;map[33][10]=true;map[33][33]=true;map[33][34]=true;map[33][35]=true;map[33][36]=true;map[33][37]=true;map[33][38]=true;map[33][39]=true;map[33][40]=true;map[33][41]=true;map[34][4]=true;map[34][5]=true;map[34][6]=true;map[34][7]=true;map[34][8]=true;map[34][9]=true;map[34][10]=true;map[34][11]=true;map[34][33]=true;map[34][34]=true;map[34][35]=true;map[34][36]=true;map[34][37]=true;map[34][38]=true;map[34][39]=true;map[34][40]=true;map[34][41]=true;map[35][4]=true;map[35][5]=true;map[35][6]=true;map[35][7]=true;map[35][8]=true;map[35][9]=true;map[35][10]=true;map[35][11]=true;map[36][4]=true;map[36][5]=true;map[36][6]=true;map[36][7]=true;map[36][8]=true;map[36][9]=true;map[36][10]=true;map[36][11]=true;map[37][4]=true;map[37][5]=true;map[37][6]=true;map[37][7]=true;map[37][8]=true;map[37][9]=true;map[37][10]=true;map[37][11]=true;map[37][23]=true;map[37][24]=true;map[38][4]=true;map[38][5]=true;map[38][6]=true;map[38][7]=true;map[38][8]=true;map[38][9]=true;map[38][10]=true;map[38][11]=true;map[38][22]=true;map[38][23]=true;map[38][24]=true;map[38][25]=true;map[39][21]=true;map[39][22]=true;map[39][23]=true;map[39][24]=true;map[39][25]=true;map[39][26]=true;map[40][21]=true;map[40][22]=true;map[40][23]=true;map[40][24]=true;map[40][25]=true;map[40][26]=true;map[41][21]=true;map[41][22]=true;map[41][23]=true;map[41][24]=true;map[41][25]=true;map[41][26]=true;map[42][22]=true;map[42][23]=true;map[42][24]=true;map[42][25]=true;		//update robot locations
		
		for (i=1;i<=rloc[0];i++){
			if (i!=rindex){
				rx=rloc[4*(i-1)+1];
				ry=rloc[4*(i-1)+2];
				if (isInside(rx,ry)) map[rx][ry]=true;
				/*
				int[8][2] ns = getNeighbors(rx,ry);
				for(int ii=0;ii<8;ii++){
					if (isInside(ns[i][0],ns[i][1])) map[ns[i][0]][ns[i][1]]=true;
				}
				*/			
			}
		}
		
		//precalculated trigonometric values
double[724] a;
a[0]=0.0;a[1]=1.0000;a[2]=0.0000;a[3]=0.0000;a[4]=2.0;a[5]=0.9994;a[6]=0.0349;a[7]=0.0349;a[8]=4.0;a[9]=0.9976;a[10]=0.0698;a[11]=0.0699;a[12]=6.0;a[13]=0.9945;a[14]=0.1045;a[15]=0.1051;a[16]=8.0;a[17]=0.9903;a[18]=0.1392;a[19]=0.1405;a[20]=10.0;a[21]=0.9848;a[22]=0.1736;a[23]=0.1763;a[24]=12.0;a[25]=0.9781;a[26]=0.2079;a[27]=0.2126;a[28]=14.0;a[29]=0.9703;a[30]=0.2419;a[31]=0.2493;a[32]=16.0;a[33]=0.9613;a[34]=0.2756;a[35]=0.2867;a[36]=18.0;a[37]=0.9511;a[38]=0.3090;a[39]=0.3249;a[40]=20.0;a[41]=0.9397;a[42]=0.3420;a[43]=0.3640;a[44]=22.0;a[45]=0.9272;a[46]=0.3746;a[47]=0.4040;a[48]=24.0;a[49]=0.9135;a[50]=0.4067;a[51]=0.4452;a[52]=26.0;a[53]=0.8988;a[54]=0.4384;a[55]=0.4877;a[56]=28.0;a[57]=0.8829;a[58]=0.4695;a[59]=0.5317;a[60]=30.0;a[61]=0.8660;a[62]=0.5000;a[63]=0.5774;a[64]=32.0;a[65]=0.8480;a[66]=0.5299;a[67]=0.6249;a[68]=34.0;a[69]=0.8290;a[70]=0.5592;a[71]=0.6745;a[72]=36.0;a[73]=0.8090;a[74]=0.5878;a[75]=0.7265;a[76]=38.0;a[77]=0.7880;a[78]=0.6157;a[79]=0.7813;a[80]=40.0;a[81]=0.7660;a[82]=0.6428;a[83]=0.8391;a[84]=42.0;a[85]=0.7431;a[86]=0.6691;a[87]=0.9004;a[88]=44.0;a[89]=0.7193;a[90]=0.6947;a[91]=0.9657;a[92]=46.0;a[93]=0.6947;a[94]=0.7193;a[95]=1.0355;a[96]=48.0;a[97]=0.6691;a[98]=0.7431;a[99]=1.1106;a[100]=50.0;a[101]=0.6428;a[102]=0.7660;a[103]=1.1918;a[104]=52.0;a[105]=0.6157;a[106]=0.7880;a[107]=1.2799;a[108]=54.0;a[109]=0.5878;a[110]=0.8090;a[111]=1.3764;a[112]=56.0;a[113]=0.5592;a[114]=0.8290;a[115]=1.4826;a[116]=58.0;a[117]=0.5299;a[118]=0.8480;a[119]=1.6003;a[120]=60.0;a[121]=0.5000;a[122]=0.8660;a[123]=1.7321;a[124]=62.0;a[125]=0.4695;a[126]=0.8829;a[127]=1.8807;a[128]=64.0;a[129]=0.4384;a[130]=0.8988;a[131]=2.0503;a[132]=66.0;a[133]=0.4067;a[134]=0.9135;a[135]=2.2460;a[136]=68.0;a[137]=0.3746;a[138]=0.9272;a[139]=2.4751;a[140]=70.0;a[141]=0.3420;a[142]=0.9397;a[143]=2.7475;a[144]=72.0;a[145]=0.3090;a[146]=0.9511;a[147]=3.0777;a[148]=74.0;a[149]=0.2756;a[150]=0.9613;a[151]=3.4874;a[152]=76.0;a[153]=0.2419;a[154]=0.9703;a[155]=4.0108;a[156]=78.0;a[157]=0.2079;a[158]=0.9781;a[159]=4.7046;a[160]=80.0;a[161]=0.1736;a[162]=0.9848;a[163]=5.6713;a[164]=82.0;a[165]=0.1392;a[166]=0.9903;a[167]=7.1154;a[168]=84.0;a[169]=0.1045;a[170]=0.9945;a[171]=9.5144;a[172]=86.0;a[173]=0.0698;a[174]=0.9976;a[175]=14.3007;a[176]=88.0;a[177]=0.0349;a[178]=0.9994;a[179]=28.6363;a[180]=90.0;a[181]=0.0000;a[182]=1.0000;a[183]=16331239353195370.0000;a[184]=92.0;a[185]=-0.0349;a[186]=0.9994;a[187]=-28.6363;a[188]=94.0;a[189]=-0.0698;a[190]=0.9976;a[191]=-14.3007;a[192]=96.0;a[193]=-0.1045;a[194]=0.9945;a[195]=-9.5144;a[196]=98.0;a[197]=-0.1392;a[198]=0.9903;a[199]=-7.1154;a[200]=100.0;a[201]=-0.1736;a[202]=0.9848;a[203]=-5.6713;a[204]=102.0;a[205]=-0.2079;a[206]=0.9781;a[207]=-4.7046;a[208]=104.0;a[209]=-0.2419;a[210]=0.9703;a[211]=-4.0108;a[212]=106.0;a[213]=-0.2756;a[214]=0.9613;a[215]=-3.4874;a[216]=108.0;a[217]=-0.3090;a[218]=0.9511;a[219]=-3.0777;a[220]=110.0;a[221]=-0.3420;a[222]=0.9397;a[223]=-2.7475;a[224]=112.0;a[225]=-0.3746;a[226]=0.9272;a[227]=-2.4751;a[228]=114.0;a[229]=-0.4067;a[230]=0.9135;a[231]=-2.2460;a[232]=116.0;a[233]=-0.4384;a[234]=0.8988;a[235]=-2.0503;a[236]=118.0;a[237]=-0.4695;a[238]=0.8829;a[239]=-1.8807;a[240]=120.0;a[241]=-0.5000;a[242]=0.8660;a[243]=-1.7321;a[244]=122.0;a[245]=-0.5299;a[246]=0.8480;a[247]=-1.6003;a[248]=124.0;a[249]=-0.5592;a[250]=0.8290;a[251]=-1.4826;a[252]=126.0;a[253]=-0.5878;a[254]=0.8090;a[255]=-1.3764;a[256]=128.0;a[257]=-0.6157;a[258]=0.7880;a[259]=-1.2799;a[260]=130.0;a[261]=-0.6428;a[262]=0.7660;a[263]=-1.1918;a[264]=132.0;a[265]=-0.6691;a[266]=0.7431;a[267]=-1.1106;a[268]=134.0;a[269]=-0.6947;a[270]=0.7193;a[271]=-1.0355;a[272]=136.0;a[273]=-0.7193;a[274]=0.6947;a[275]=-0.9657;a[276]=138.0;a[277]=-0.7431;a[278]=0.6691;a[279]=-0.9004;a[280]=140.0;a[281]=-0.7660;a[282]=0.6428;a[283]=-0.8391;a[284]=142.0;a[285]=-0.7880;a[286]=0.6157;a[287]=-0.7813;a[288]=144.0;a[289]=-0.8090;a[290]=0.5878;a[291]=-0.7265;a[292]=146.0;a[293]=-0.8290;a[294]=0.5592;a[295]=-0.6745;a[296]=148.0;a[297]=-0.8480;a[298]=0.5299;a[299]=-0.6249;a[300]=150.0;a[301]=-0.8660;a[302]=0.5000;a[303]=-0.5774;a[304]=152.0;a[305]=-0.8829;a[306]=0.4695;a[307]=-0.5317;a[308]=154.0;a[309]=-0.8988;a[310]=0.4384;a[311]=-0.4877;a[312]=156.0;a[313]=-0.9135;a[314]=0.4067;a[315]=-0.4452;a[316]=158.0;a[317]=-0.9272;a[318]=0.3746;a[319]=-0.4040;a[320]=160.0;a[321]=-0.9397;a[322]=0.3420;a[323]=-0.3640;a[324]=162.0;a[325]=-0.9511;a[326]=0.3090;a[327]=-0.3249;a[328]=164.0;a[329]=-0.9613;a[330]=0.2756;a[331]=-0.2867;a[332]=166.0;a[333]=-0.9703;a[334]=0.2419;a[335]=-0.2493;a[336]=168.0;a[337]=-0.9781;a[338]=0.2079;a[339]=-0.2126;a[340]=170.0;a[341]=-0.9848;a[342]=0.1736;a[343]=-0.1763;a[344]=172.0;a[345]=-0.9903;a[346]=0.1392;a[347]=-0.1405;a[348]=174.0;a[349]=-0.9945;a[350]=0.1045;a[351]=-0.1051;a[352]=176.0;a[353]=-0.9976;a[354]=0.0698;a[355]=-0.0699;a[356]=178.0;a[357]=-0.9994;a[358]=0.0349;a[359]=-0.0349;a[360]=180.0;a[361]=-1.0000;a[362]=0.0000;a[363]=0.0000;a[364]=182.0;a[365]=-0.9994;a[366]=-0.0349;a[367]=0.0349;a[368]=184.0;a[369]=-0.9976;a[370]=-0.0698;a[371]=0.0699;a[372]=186.0;a[373]=-0.9945;a[374]=-0.1045;a[375]=0.1051;a[376]=188.0;a[377]=-0.9903;a[378]=-0.1392;a[379]=0.1405;a[380]=190.0;a[381]=-0.9848;a[382]=-0.1736;a[383]=0.1763;a[384]=192.0;a[385]=-0.9781;a[386]=-0.2079;a[387]=0.2126;a[388]=194.0;a[389]=-0.9703;a[390]=-0.2419;a[391]=0.2493;a[392]=196.0;a[393]=-0.9613;a[394]=-0.2756;a[395]=0.2867;a[396]=198.0;a[397]=-0.9511;a[398]=-0.3090;a[399]=0.3249;a[400]=200.0;a[401]=-0.9397;a[402]=-0.3420;a[403]=0.3640;
a[404]=202.0;a[405]=-0.9272;a[406]=-0.3746;a[407]=0.4040;a[408]=204.0;a[409]=-0.9135;a[410]=-0.4067;a[411]=0.4452;a[412]=206.0;a[413]=-0.8988;a[414]=-0.4384;a[415]=0.4877;a[416]=208.0;a[417]=-0.8829;a[418]=-0.4695;a[419]=0.5317;a[420]=210.0;a[421]=-0.8660;a[422]=-0.5000;a[423]=0.5774;a[424]=212.0;a[425]=-0.8480;a[426]=-0.5299;a[427]=0.6249;a[428]=214.0;a[429]=-0.8290;a[430]=-0.5592;a[431]=0.6745;a[432]=216.0;a[433]=-0.8090;a[434]=-0.5878;a[435]=0.7265;a[436]=218.0;a[437]=-0.7880;a[438]=-0.6157;a[439]=0.7813;a[440]=220.0;a[441]=-0.7660;a[442]=-0.6428;a[443]=0.8391;a[444]=222.0;a[445]=-0.7431;a[446]=-0.6691;a[447]=0.9004;a[448]=224.0;a[449]=-0.7193;a[450]=-0.6947;a[451]=0.9657;a[452]=226.0;a[453]=-0.6947;a[454]=-0.7193;a[455]=1.0355;a[456]=228.0;a[457]=-0.6691;a[458]=-0.7431;a[459]=1.1106;a[460]=230.0;a[461]=-0.6428;a[462]=-0.7660;a[463]=1.1918;a[464]=232.0;a[465]=-0.6157;a[466]=-0.7880;a[467]=1.2799;a[468]=234.0;a[469]=-0.5878;a[470]=-0.8090;a[471]=1.3764;a[472]=236.0;a[473]=-0.5592;a[474]=-0.8290;a[475]=1.4826;a[476]=238.0;a[477]=-0.5299;a[478]=-0.8480;a[479]=1.6003;a[480]=240.0;a[481]=-0.5000;a[482]=-0.8660;a[483]=1.7321;a[484]=242.0;a[485]=-0.4695;a[486]=-0.8829;a[487]=1.8807;a[488]=244.0;a[489]=-0.4384;a[490]=-0.8988;a[491]=2.0503;a[492]=246.0;a[493]=-0.4067;a[494]=-0.9135;a[495]=2.2460;a[496]=248.0;a[497]=-0.3746;a[498]=-0.9272;a[499]=2.4751;a[500]=250.0;a[501]=-0.3420;a[502]=-0.9397;a[503]=2.7475;a[504]=252.0;a[505]=-0.3090;a[506]=-0.9511;a[507]=3.0777;a[508]=254.0;a[509]=-0.2756;a[510]=-0.9613;a[511]=3.4874;a[512]=256.0;a[513]=-0.2419;a[514]=-0.9703;a[515]=4.0108;a[516]=258.0;a[517]=-0.2079;a[518]=-0.9781;a[519]=4.7046;a[520]=260.0;a[521]=-0.1736;a[522]=-0.9848;a[523]=5.6713;a[524]=262.0;a[525]=-0.1392;a[526]=-0.9903;a[527]=7.1154;a[528]=264.0;a[529]=-0.1045;a[530]=-0.9945;a[531]=9.5144;a[532]=266.0;a[533]=-0.0698;a[534]=-0.9976;a[535]=14.3007;a[536]=268.0;a[537]=-0.0349;a[538]=-0.9994;a[539]=28.6363;a[540]=270.0;a[541]=0.0000;a[542]=-1.0000;a[543]=5443746451065123.0000;a[544]=272.0;a[545]=0.0349;a[546]=-0.9994;a[547]=-28.6363;a[548]=274.0;a[549]=0.0698;a[550]=-0.9976;a[551]=-14.3007;a[552]=276.0;a[553]=0.1045;a[554]=-0.9945;a[555]=-9.5144;a[556]=278.0;a[557]=0.1392;a[558]=-0.9903;a[559]=-7.1154;a[560]=280.0;a[561]=0.1736;a[562]=-0.9848;a[563]=-5.6713;a[564]=282.0;a[565]=0.2079;a[566]=-0.9781;a[567]=-4.7046;a[568]=284.0;a[569]=0.2419;a[570]=-0.9703;a[571]=-4.0108;a[572]=286.0;a[573]=0.2756;a[574]=-0.9613;a[575]=-3.4874;a[576]=288.0;a[577]=0.3090;a[578]=-0.9511;a[579]=-3.0777;a[580]=290.0;a[581]=0.3420;a[582]=-0.9397;a[583]=-2.7475;a[584]=292.0;a[585]=0.3746;a[586]=-0.9272;a[587]=-2.4751;a[588]=294.0;a[589]=0.4067;a[590]=-0.9135;a[591]=-2.2460;a[592]=296.0;a[593]=0.4384;a[594]=-0.8988;a[595]=-2.0503;a[596]=298.0;a[597]=0.4695;a[598]=-0.8829;a[599]=-1.8807;a[600]=300.0;a[601]=0.5000;a[602]=-0.8660;a[603]=-1.7321;a[604]=302.0;a[605]=0.5299;a[606]=-0.8480;a[607]=-1.6003;a[608]=304.0;a[609]=0.5592;a[610]=-0.8290;a[611]=-1.4826;a[612]=306.0;a[613]=0.5878;a[614]=-0.8090;a[615]=-1.3764;a[616]=308.0;a[617]=0.6157;a[618]=-0.7880;a[619]=-1.2799;a[620]=310.0;a[621]=0.6428;a[622]=-0.7660;a[623]=-1.1918;a[624]=312.0;a[625]=0.6691;a[626]=-0.7431;a[627]=-1.1106;a[628]=314.0;a[629]=0.6947;a[630]=-0.7193;a[631]=-1.0355;a[632]=316.0;a[633]=0.7193;a[634]=-0.6947;a[635]=-0.9657;a[636]=318.0;a[637]=0.7431;a[638]=-0.6691;a[639]=-0.9004;a[640]=320.0;a[641]=0.7660;a[642]=-0.6428;a[643]=-0.8391;a[644]=322.0;a[645]=0.7880;a[646]=-0.6157;a[647]=-0.7813;a[648]=324.0;a[649]=0.8090;a[650]=-0.5878;a[651]=-0.7265;a[652]=326.0;a[653]=0.8290;a[654]=-0.5592;a[655]=-0.6745;a[656]=328.0;a[657]=0.8480;a[658]=-0.5299;a[659]=-0.6249;a[660]=330.0;a[661]=0.8660;a[662]=-0.5000;a[663]=-0.5774;a[664]=332.0;a[665]=0.8829;a[666]=-0.4695;a[667]=-0.5317;a[668]=334.0;a[669]=0.8988;a[670]=-0.4384;a[671]=-0.4877;a[672]=336.0;a[673]=0.9135;a[674]=-0.4067;a[675]=-0.4452;a[676]=338.0;a[677]=0.9272;a[678]=-0.3746;a[679]=-0.4040;a[680]=340.0;a[681]=0.9397;a[682]=-0.3420;a[683]=-0.3640;a[684]=342.0;a[685]=0.9511;a[686]=-0.3090;a[687]=-0.3249;a[688]=344.0;a[689]=0.9613;a[690]=-0.2756;a[691]=-0.2867;a[692]=346.0;a[693]=0.9703;a[694]=-0.2419;a[695]=-0.2493;a[696]=348.0;a[697]=0.9781;a[698]=-0.2079;a[699]=-0.2126;a[700]=350.0;a[701]=0.9848;a[702]=-0.1736;a[703]=-0.1763;a[704]=352.0;a[705]=0.9903;a[706]=-0.1392;a[707]=-0.1405;a[708]=354.0;a[709]=0.9945;a[710]=-0.1045;a[711]=-0.1051;a[712]=356.0;a[713]=0.9976;a[714]=-0.0698;a[715]=-0.0699;a[716]=358.0;a[717]=0.9994;a[718]=-0.0349;a[719]=-0.0349;a[720]=360.0;a[721]=1.0000;a[722]=0.0000;a[723]=0.0000;

		rx = rloc[4*(rindex-1)+1];
		ry = rloc[4*(rindex-1)+2];
		rdir = rloc[4*(rindex-1)+3];
		
		double angleRobot = getAngleFromDir(rdir);	
		double angleMin = angleRobot - fov/2;
		double angleMax = angleRobot + fov/2;
		int inc = angleMin < angleMax ? 1:-1;
				
	  	int beams = round( abs(angleMax - angleMin) / ANGLE_INC );
	  	//max_distance = (int)max( max(rx,MAP_ROWS-rx), max(ry,MAP_COLS-ry) );
	  	int step = 1;//round( min(MAP_ROWS, MAP_COLS) / max_distance );

		int max_ai = (int)(360 / ANGLE_INC);
		int ai = (int)(angleMin / ANGLE_INC);
		int ai_n,x,y;
		double range,cosa,sina;
		// Iterate over each angle
		for (i=0; i < beams; i+=inc, ai+=inc) {
			ai_n = (ai>=0?ai:max_ai+ai) % max_ai;
			//if (ai_n>max_ai) ai_n-=max_ai;
			cosa = a[4*ai_n+1];
			sina = a[4*ai_n+2];
			
			// Initialize the range for this angle to the maximum range
			range = INFINITY;				

			// Iterate over each step along the current ray
			for (j = 1; j <= max_distance; j += step) {
				// Calculate the current position along the ray
				x = (int)(rx + j * cosa);
				y = (int)(ry + j * sina);
				// Check if the current position is within the grid
				if (self.isInside(x,y)){  
					if(map[x][y]) {
						// Update the range for this angle
						range = j;	//edistance(rx,ry,x,y)?
						// Store the range for this angle in the ranges array
						//int[2] p = getNewCoord(x,y,rx,ry,rdir);
						//int code = xy2idx(p[0],p[1]);
						int code = xy2idx(x,y);
						//only add new obstacles
						if (scandata[0]==0 || (scandata[0]>0 && scandata[scandata[0]]!=code) ){
							scandata[0]++;
							scandata[scandata[0]] = code;
							angles[0]++;
							angles[angles[0]] = ai_n;
						}
						break;	//take only first block, do not see after it
					}
				} else {
				/*
					if (x<0) x = 0;
					if (x>MAP_ROWS-1) x = MAP_ROWS-1;
					if (y<0) y = 0;
					if (y>MAP_COLS-1) y = MAP_COLS-1;
					int code = xy2idx(x,y);
					//only add new obstacles
					if (scandata[0]==0 || (scandata[0]>0 && scandata[scandata[0]]!=code) ){
						scandata[0]++;
						scandata[scandata[0]] = code;
						angles[0]++;
						angles[angles[0]] = ai_n;
					}
					*/
					break;		
				}
			}
			//set range for this angle
 			
 			//ranges[0]++;
  			//ranges[ranges[0]]=range;
 		}
		n.onLaserScan(scandata, angles) deadline(LASERSCAN_RATE+5);	
		scanObstacles(n,rindex,rate,fov,max_distance) after(rate);
	}
		
	//a robot calls this msgsrv to tell the map server to keep track of its new location
	@priority(5)
	msgsrv updateRobotLocation(int idx, int rx, int ry, int rdir,int velocity){
		int i = (idx-1)*4;
		rloc[i+1] = rx;
		rloc[i+2] = ry;
		rloc[i+3] = rdir;
		rloc[i+4] = velocity>0?1:0;	//is moving
		//collision check
		for(i=1;i<=rloc[0];i++){
			if (i!=idx){
				assertion(!(rx==rloc[4*(i-1)+1] && ry==rloc[4*(i-1)+2]),"Collision with another robot!");
			}
		}
	}
	
	//encode two integers (-999 to 999) into one integer 
	//e.g: 23-->1023, -23->2023, code2 = code_y * 10000 + code_x
	//(3,-200) --> 1003*10000 + 2200 = 10032200
	int xy2idx(int ox,int oy){
		int x,sx,y,sy;	
		if (ox<0){
			sx=2;x=-ox;
		}else{
			sx=1;x=ox;		
		}
		if (oy<0){
			sy=2;y=-oy;
		}else{
			sy=1;y=oy;		
		}
		int ex = sx*1000 + x;
		int ey = sy*1000 + y;
		int idx = ey*10000 + ex;
		return idx;
	}
	
	//decode
	int[2] idx2xy(int idx){
		int ex = idx % 10000;
		int ey = (idx - ex) / 10000;
		int sx = (int)(ex/1000);
		int x = ex % 1000;
		int sy = (int)(ey/1000);
		int y = ey % 1000;
		if (sx==2) x=-x;
		if (sy==2) y=-y;
		int[2] ret;ret[0]=x;ret[1]=y;
		return ret;
	}
	
	boolean[50/*MAP_ROWS*/][50/*MAP_COLS*/] expandObstacles(boolean[50/*MAP_ROWS*/][50/*MAP_COLS*/] map){
		boolean[50/*MAP_ROWS*/][50/*MAP_COLS*/] map2;
		int[8][2] neighbors = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};
		for(int i=0;i<MAP_ROWS;i++){
			for(int j=0;j<MAP_COLS;j++){
				map2[i][j] = map[i][j];
				if (map[i][j]) {
					for(int k=0;k<8;k++){
						int nx = i+neighbors[k][0];
						int ny = j+neighbors[k][1];
						if (nx>=0 && nx<MAP_ROWS && ny>=0 && ny<MAP_COLS && !map[nx][ny]) 
							map2[nx][ny]=true;
					}
				}
			}
		}
		return map2;
	}
	
	int[2] getNeighborAtDir(int x, int y, int dir){
		//neighboring cells in 8 directions: e, ne, n, nw, w, sw, s, se
		int[8][2] nxt = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};
		dir%=8;
		if (dir<0)dir+=8;
		int[2] p ;
		p[0] = x + nxt[dir][0];
		p[1] = y + nxt[dir][1];
		return p;	
	}
	
	int[8][2] getNeighbors(int x, int y){
		//neighboring cells in 8 directions: e, ne, n, nw, w, sw, s, se
		int[8][2] nxt = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};
		int[8][2] p ;
		for(int i=0;i<8;i++){
			p[i][0] = x + nxt[i][0];
			p[i][1] = y + nxt[i][1];
		}
		return p;	
	}
	
	//generate a path from (x,y) to (targetX,targetY) using a selected algorithm
	@priority(3)
	msgsrv generatePath(Node node,int x, int y, int dir, int targetX, int targetY, int[8] blockdir){		
		//prepare occupancy grid with static obstacles and mobile obstacles
		
		//neighboring cells in 8 directions: e, ne, n, nw, w, sw, s, se
		int[8][2] nxt = {{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};
			
		int i,j;		
		boolean[50/*MAP_ROWS*/][50/*MAP_COLS*/] map;
		for(i=0;i<MAP_ROWS;i++)for(j=0;j<MAP_COLS;j++)map[i][j]=false;		
map[8][18]=true;map[8][19]=true;map[8][20]=true;map[8][21]=true;map[8][22]=true;map[9][18]=true;map[9][19]=true;map[9][20]=true;map[9][21]=true;map[9][22]=true;map[10][18]=true;map[10][19]=true;map[10][20]=true;map[10][21]=true;map[10][22]=true;map[11][18]=true;map[11][19]=true;map[11][20]=true;map[11][21]=true;map[11][22]=true;map[12][18]=true;map[12][19]=true;map[12][20]=true;map[12][21]=true;map[12][22]=true;map[13][18]=true;map[13][19]=true;map[13][20]=true;map[13][21]=true;map[13][22]=true;map[14][18]=true;map[14][19]=true;map[14][20]=true;map[14][21]=true;map[14][22]=true;map[15][18]=true;map[15][19]=true;map[15][20]=true;map[15][21]=true;map[15][22]=true;map[16][18]=true;map[16][19]=true;map[16][20]=true;map[16][21]=true;map[16][22]=true;map[17][18]=true;map[17][19]=true;map[17][20]=true;map[17][21]=true;map[17][22]=true;map[18][18]=true;map[18][19]=true;map[18][20]=true;map[18][21]=true;map[18][22]=true;map[19][18]=true;map[19][19]=true;map[19][20]=true;map[19][21]=true;map[19][22]=true;map[20][18]=true;map[20][19]=true;map[20][20]=true;map[20][21]=true;map[20][22]=true;map[21][18]=true;map[21][19]=true;map[21][20]=true;map[21][21]=true;map[21][22]=true;map[22][18]=true;map[22][19]=true;map[22][20]=true;map[22][21]=true;map[22][22]=true;map[23][18]=true;map[23][19]=true;map[23][20]=true;map[23][21]=true;map[23][22]=true;map[24][18]=true;map[24][19]=true;map[24][20]=true;map[24][21]=true;map[24][22]=true;map[25][18]=true;map[25][19]=true;map[25][20]=true;map[25][21]=true;map[25][22]=true;map[26][19]=true;map[26][20]=true;map[26][21]=true;map[30][33]=true;map[30][34]=true;map[30][35]=true;map[30][36]=true;map[30][37]=true;map[30][38]=true;map[30][39]=true;map[30][40]=true;map[30][41]=true;map[31][33]=true;map[31][34]=true;map[31][35]=true;map[31][36]=true;map[31][37]=true;map[31][38]=true;map[31][39]=true;map[31][40]=true;map[31][41]=true;map[32][33]=true;map[32][34]=true;map[32][35]=true;map[32][36]=true;map[32][37]=true;map[32][38]=true;map[32][39]=true;map[32][40]=true;map[32][41]=true;map[33][4]=true;map[33][5]=true;map[33][6]=true;map[33][7]=true;map[33][8]=true;map[33][9]=true;map[33][10]=true;map[33][33]=true;map[33][34]=true;map[33][35]=true;map[33][36]=true;map[33][37]=true;map[33][38]=true;map[33][39]=true;map[33][40]=true;map[33][41]=true;map[34][4]=true;map[34][5]=true;map[34][6]=true;map[34][7]=true;map[34][8]=true;map[34][9]=true;map[34][10]=true;map[34][11]=true;map[34][33]=true;map[34][34]=true;map[34][35]=true;map[34][36]=true;map[34][37]=true;map[34][38]=true;map[34][39]=true;map[34][40]=true;map[34][41]=true;map[35][4]=true;map[35][5]=true;map[35][6]=true;map[35][7]=true;map[35][8]=true;map[35][9]=true;map[35][10]=true;map[35][11]=true;map[36][4]=true;map[36][5]=true;map[36][6]=true;map[36][7]=true;map[36][8]=true;map[36][9]=true;map[36][10]=true;map[36][11]=true;map[37][4]=true;map[37][5]=true;map[37][6]=true;map[37][7]=true;map[37][8]=true;map[37][9]=true;map[37][10]=true;map[37][11]=true;map[37][23]=true;map[37][24]=true;map[38][4]=true;map[38][5]=true;map[38][6]=true;map[38][7]=true;map[38][8]=true;map[38][9]=true;map[38][10]=true;map[38][11]=true;map[38][22]=true;map[38][23]=true;map[38][24]=true;map[38][25]=true;map[39][21]=true;map[39][22]=true;map[39][23]=true;map[39][24]=true;map[39][25]=true;map[39][26]=true;map[40][21]=true;map[40][22]=true;map[40][23]=true;map[40][24]=true;map[40][25]=true;map[40][26]=true;map[41][21]=true;map[41][22]=true;map[41][23]=true;map[41][24]=true;map[41][25]=true;map[41][26]=true;map[42][22]=true;map[42][23]=true;map[42][24]=true;map[42][25]=true;		

		//expand obstacles by 1 cell around it to avoid collision
		map = expandObstacles(map);
		//expand more if required
		int max_expands = SAFE_MARGIN + round(ROBOT_BREADTH/2);			
		for(i=1;i<max_expands;i++){	
			map = expandObstacles(map);
		}
				
		for (i=0;i<rloc[0];i++){
			int rx=rloc[4*i+1];
			int ry=rloc[4*i+2];
			if (isInside(rx,ry)) map[rx][ry]=true;
			//if robot is moving, mark next #STOP_ZONE cells in its moving direction as occupied (in the future)
			int rdir = rloc[4*i+3];
			boolean isMoving = rloc[4*i+4]!=0;
			if (isMoving){
				for (j=0;j<STOP_ZONE;j++){
					int[2] p = getNeighborAtDir(rx,ry,rdir);
					if (isInside(p[0],p[1])) {
						map[p[0]][p[1]]=true;						
					}
					rx = p[0]; ry=p[1];
				}
			}
		}
		
		//regenerate path, try to find a new one by blocking the old direction
		if (false && blockdir[0]>0){
			for(i=1;i<=blockdir[0];i++){
				int[2] np = getNeighborAtDir(x,y,blockdir[i]);
				if (isInside(np[0],np[1])) map[np[0]][np[1]]=true; //else break;
			}
		}
				
		int k,lk,li,lj;
		
		int[512] open; open[0]=0;
		
		double[50/*MAP_ROWS*/][50/*MAP_COLS*/][5] nodes;
		
		for(i=0;i<MAP_ROWS;i++){
			for(j=0;j<MAP_COLS;j++){
				nodes[i][j][0]=0;	//unchecked
				nodes[i][j][1]=INFINITY;	//g_score = distance to starting point
				nodes[i][j][2]=INFINITY;	//h_score = distance to ending point, f_score = g_score + h_score
				nodes[i][j][3]=-1;	//preceding cell that leads to this cell
				nodes[i][j][4]=-1;
			}
		}
		//add starting point
		open[0]=1;
		open[1]=xy2idx(x,y);
		
		nodes[x][y][0]=1;
		nodes[x][y][1]=0;//g_score
		nodes[x][y][2]=odistance(x,y,targetX,targetY);//h_score
						
		boolean found=false;
		while (true){
			double lf=INFINITY;
			lk=-1; li=-1; lj=-1;
			for(k=1;k<=open[0];k++){
				if (open[k]>=0){
					int[2] ij = idx2xy(open[k]);
					i = ij[0];
					j = ij[1];
					if (i>=0 && j>=0 && (nodes[i][j][1] + nodes[i][j][2]) < lf){
							lf=nodes[i][j][1] + nodes[i][j][2];
							li=i;lj=j;lk=k;	
					}
				}
			}
			if (li<0 || lj<0) {
				found = false;
				break;
			}
			nodes[li][lj][0]=1;//visisted
			
			if (li==targetX && lj==targetY){
				//found path
				found = true;
				break;
			}
			
			//remove from open list		
			//open = removeFromList(open,lk); this function is not used because Rebeca has error in passing parameters of large array type 			
			int[512] topen; //copy array
			for(i=0;i<512;i++) topen[i]=open[i];				
			open[0]=0;
			if (topen[0]>0 && lk>=1 && lk<=topen[0]){
				open[0]=topen[0]-1;
				for(i=1;i<lk;i++){
					open[i]=topen[i];
				}
				for(i=lk;i<topen[0];i++){
					open[i]=topen[i+1];
				}
			}
			
			for(k=0;k<7;k++){
				int nx = li + nxt[k][0];
				int ny = lj + nxt[k][1];
				if (between(nx,0,MAP_ROWS-1) && between(ny,0,MAP_COLS-1)){
					if (0==nodes[nx][ny][0] && false==map[nx][ny]){					
						double g = nodes[li][lj][1] + ((nx==li||ny==lj)?1:SQRT2);
						if (g < nodes[nx][ny][1]){
							nodes[nx][ny][0] = 0;
							nodes[nx][ny][1] = g;
							nodes[nx][ny][2] = odistance(nx,ny,targetX,targetY);	
							nodes[nx][ny][3] = li;
							nodes[nx][ny][4] = lj;		
							
							boolean added = false;
							int code = xy2idx(nx,ny);
							for(i=1;i<=open[0];i++) if (open[i]==code) {added=true;break;}
							if (!added){
								open[0]++;
								open[open[0]]=code;
							}
						}
					}
				}
			}
		}
		
		int[101/*BUFFER_SIZE*/] path, rpath;
		for(i=0;i<BUFFER_SIZE;i++){ path[i]=0; rpath[i]=0; }
		
		if (found){
			//construct the path based on traceback graph 
			i=targetX;j=targetY;
			rpath[0]=1;
			rpath[1]=xy2idx(targetX,targetY);
			while(true){
				li=(int)nodes[i][j][3];
				lj=(int)nodes[i][j][4];
				if (li>=0 && lj>=0){
					rpath[0]++;
					rpath[rpath[0]] = xy2idx(li,lj);
				} else {
					break;
				}
				i = li; j=lj;
			}
			//get it in reversed order
			path[0]=0;
			for(i=rpath[0];i>0;i--){
				path[0]++;
				path[path[0]]=rpath[i];
			}
			assertion(path[1]==xy2idx(x,y) && path[path[0]] == xy2idx(targetX,targetY),"Incorrect path");
			
		} else {
			//assertion(false,"Path not found");				
		}
		
		node.onNewPath(path);
	}
	
}

main {
	//higher priority to faster robot
	@priority(6) Node r1(theMap):(1,0,0,48,48,8,true,false,500);
	@priority(3) Node r2(theMap):(2,0,10,48,38,4,true,true,800);
	@priority(2) Node r3(theMap):(3,0,20,48,28,4,true,true,1100);
	@priority(4) Node r4(theMap):(4,0,30,48,18,4,true,false,1400);
	@priority(5) Node r5(theMap):(5,0,40,48,8,8,true,false,1700);	
	@priority(1) MapServer theMap(r1,r2,r3,r4,r5):(5);
}
